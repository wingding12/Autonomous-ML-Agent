"""
E2B Sandbox Manager for the Autonomous ML Agent.

This module manages E2B sandboxes for secure, isolated code execution
of ML workflows generated by LLMs.
"""

import asyncio
import logging
import tempfile
from pathlib import Path
from typing import Dict, List, Optional, Any, Union
import json

from e2b import Sandbox

from config.settings import Settings
from utils.logger import get_logger

logger = get_logger(__name__)

class E2BManager:
    """
    Manager for E2B sandbox operations.
    
    This class handles the creation, management, and cleanup of E2B sandboxes
    for executing ML code in isolated environments.
    """
    
    def __init__(self, settings: Settings):
        """Initialize the E2B manager."""
        self.settings = settings
        self.api_key = settings.E2B_API_KEY
        self.template_id = settings.E2B_TEMPLATE_ID
        self.timeout = settings.E2B_SANDBOX_TIMEOUT
        
        # Active sandboxes
        self.active_sandboxes: Dict[str, Sandbox] = {}
        self.sandbox_metadata: Dict[str, Dict[str, Any]] = {}
        
        # Initialize E2B
        self.enabled: bool = False
        self._configure_e2b()
        
        logger.info("E2B Manager initialized")
    
    def _configure_e2b(self) -> None:
        """Configure E2B with API key."""
        try:
            if not self.api_key:
                self.enabled = False
                logger.warning("E2B API key not set. Sandbox features are disabled.")
                return
            # The e2b package reads API key from env; here we just mark enabled
            self.enabled = True
            logger.info("E2B configured successfully and enabled")
        except Exception as e:
            logger.error(f"Failed to configure E2B: {e}")
            raise
    
    async def initialize(self) -> None:
        """Initialize the E2B manager."""
        logger.info("E2B Manager initialization completed")
    
    async def cleanup(self) -> None:
        """Clean up all active sandboxes."""
        try:
            logger.info("Cleaning up E2B sandboxes...")
            
            # Terminate all active sandboxes
            for sandbox_id, sandbox in self.active_sandboxes.items():
                try:
                    await self.terminate_sandbox(sandbox_id)
                except Exception as e:
                    logger.warning(f"Failed to terminate sandbox {sandbox_id}: {e}")
            
            logger.info("E2B Manager cleanup completed")
            
        except Exception as e:
            logger.error(f"Error during E2B cleanup: {e}")
    
    async def create_sandbox(
        self,
        sandbox_id: str,
        template_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> str:
        """
        Create a new E2B sandbox.
        
        Args:
            sandbox_id: Unique identifier for the sandbox
            template_id: E2B template to use (defaults to configured template)
            timeout: Sandbox timeout in seconds
            
        Returns:
            Sandbox ID
        """
        try:
            if not self.enabled:
                raise RuntimeError("E2B is disabled. Set E2B_API_KEY to enable sandboxes.")
            template = template_id or self.template_id
            sandbox_timeout = timeout or self.timeout
            
            logger.info(f"Creating E2B sandbox {sandbox_id} with template {template}")
            
            # Create sandbox (v0.12 API)
            sandbox = Sandbox(template=template, timeout=sandbox_timeout)
            
            # Store sandbox reference
            self.active_sandboxes[sandbox_id] = sandbox
            self.sandbox_metadata[sandbox_id] = {
                "template": template,
                "timeout": sandbox_timeout,
                "created_at": asyncio.get_event_loop().time(),
                "status": "active"
            }
            
            logger.info(f"E2B sandbox {sandbox_id} created successfully")
            return sandbox_id
            
        except Exception as e:
            logger.error(f"Failed to create sandbox {sandbox_id}: {e}")
            raise
    
    async def terminate_sandbox(self, sandbox_id: str) -> bool:
        """
        Terminate an E2B sandbox.
        
        Args:
            sandbox_id: ID of the sandbox to terminate
            
        Returns:
            True if sandbox was terminated successfully
        """
        try:
            if not self.enabled:
                raise RuntimeError("E2B is disabled. Set E2B_API_KEY to enable sandboxes.")
            if sandbox_id not in self.active_sandboxes:
                logger.warning(f"Sandbox {sandbox_id} not found")
                return False
            
            sandbox = self.active_sandboxes[sandbox_id]
            
            # Terminate sandbox
            await sandbox.close()
            
            # Remove from active sandboxes
            del self.active_sandboxes[sandbox_id]
            
            # Update metadata
            if sandbox_id in self.sandbox_metadata:
                self.sandbox_metadata[sandbox_id]["status"] = "terminated"
                self.sandbox_metadata[sandbox_id]["terminated_at"] = asyncio.get_event_loop().time()
            
            logger.info(f"Sandbox {sandbox_id} terminated successfully")
            return True
            
        except Exception as e:
            logger.error(f"Failed to terminate sandbox {sandbox_id}: {e}")
            return False
    
    async def execute_code(
        self,
        sandbox_id: str,
        code: str,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Execute code in an E2B sandbox.
        
        Args:
            sandbox_id: ID of the sandbox to execute code in
            code: Python code to execute
            timeout: Execution timeout in seconds
            
        Returns:
            Execution results
        """
        try:
            if not self.enabled:
                raise RuntimeError("E2B is disabled. Set E2B_API_KEY to enable sandboxes.")
            if sandbox_id not in self.active_sandboxes:
                raise ValueError(f"Sandbox {sandbox_id} not found")
            
            sandbox = self.active_sandboxes[sandbox_id]
            execution_timeout = timeout or 300  # 5 minutes default
            
            logger.info(f"Executing code in sandbox {sandbox_id}")
            
            # Execute code
            result = await sandbox.run_python(
                code,
                timeout=execution_timeout
            )
            
            # Parse results
            execution_result = {
                "sandbox_id": sandbox_id,
                "code": code,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "exit_code": result.exit_code,
                "execution_time": result.execution_time,
                "success": result.exit_code == 0,
                "timestamp": asyncio.get_event_loop().time()
            }
            
            logger.info(f"Code execution completed in sandbox {sandbox_id}")
            return execution_result
            
        except Exception as e:
            logger.error(f"Code execution failed in sandbox {sandbox_id}: {e}")
            raise
    
    async def upload_file(
        self,
        sandbox_id: str,
        local_path: Union[str, Path],
        remote_path: Optional[str] = None
    ) -> bool:
        """
        Upload a file to an E2B sandbox.
        
        Args:
            sandbox_id: ID of the sandbox
            local_path: Path to local file
            remote_path: Path in sandbox (defaults to filename)
            
        Returns:
            True if upload was successful
        """
        try:
            if not self.enabled:
                raise RuntimeError("E2B is disabled. Set E2B_API_KEY to enable sandboxes.")
            if sandbox_id not in self.active_sandboxes:
                raise ValueError(f"Sandbox {sandbox_id} not found")
            
            sandbox = self.active_sandboxes[sandbox_id]
            local_file = Path(local_path)
            
            if not local_file.exists():
                raise FileNotFoundError(f"Local file not found: {local_path}")
            
            # Set remote path if not specified
            if remote_path is None:
                remote_path = local_file.name
            
            logger.info(f"Uploading {local_path} to sandbox {sandbox_id} as {remote_path}")
            
            # Upload file
            with open(local_file, 'rb') as f:
                await sandbox.upload_file(remote_path, f.read())
            
            logger.info(f"File uploaded successfully to sandbox {sandbox_id}")
            return True
            
        except Exception as e:
            logger.error(f"File upload failed to sandbox {sandbox_id}: {e}")
            raise
    
    async def download_file(
        self,
        sandbox_id: str,
        remote_path: str,
        local_path: Union[str, Path]
    ) -> bool:
        """
        Download a file from an E2B sandbox.
        
        Args:
            sandbox_id: ID of the sandbox
            remote_path: Path to file in sandbox
            local_path: Local path to save file
            
        Returns:
            True if download was successful
        """
        try:
            if not self.enabled:
                raise RuntimeError("E2B is disabled. Set E2B_API_KEY to enable sandboxes.")
            if sandbox_id not in self.active_sandboxes:
                raise ValueError(f"Sandbox {sandbox_id} not found")
            
            sandbox = self.active_sandboxes[sandbox_id]
            local_file = Path(local_path)
            
            logger.info(f"Downloading {remote_path} from sandbox {sandbox_id} to {local_path}")
            
            # Download file
            file_content = await sandbox.download_file(remote_path)
            
            # Save to local file
            local_file.parent.mkdir(parents=True, exist_ok=True)
            with open(local_file, 'wb') as f:
                f.write(file_content)
            
            logger.info(f"File downloaded successfully from sandbox {sandbox_id}")
            return True
            
        except Exception as e:
            logger.error(f"File download failed from sandbox {sandbox_id}: {e}")
            raise
    
    async def list_files(self, sandbox_id: str, path: str = "/") -> List[Dict[str, Any]]:
        """
        List files in an E2B sandbox.
        
        Args:
            sandbox_id: ID of the sandbox
            path: Path to list files from
            
        Returns:
            List of file information
        """
        try:
            if not self.enabled:
                raise RuntimeError("E2B is disabled. Set E2B_API_KEY to enable sandboxes.")
            if sandbox_id not in self.active_sandboxes:
                raise ValueError(f"Sandbox {sandbox_id} not found")
            
            sandbox = self.active_sandboxes[sandbox_id]
            
            # List files
            files = await sandbox.list_files(path)
            
            return [
                {
                    "name": file.name,
                    "path": file.path,
                    "size": file.size,
                    "type": file.type,
                    "modified": file.modified
                }
                for file in files
            ]
            
        except Exception as e:
            logger.error(f"Failed to list files in sandbox {sandbox_id}: {e}")
            raise
    
    async def get_sandbox_status(self, sandbox_id: str) -> Dict[str, Any]:
        """
        Get status of an E2B sandbox.
        
        Args:
            sandbox_id: ID of the sandbox
            
        Returns:
            Sandbox status information
        """
        try:
            if not self.enabled:
                raise RuntimeError("E2B is disabled. Set E2B_API_KEY to enable sandboxes.")
            if sandbox_id not in self.active_sandboxes:
                raise ValueError(f"Sandbox {sandbox_id} not found")
            
            sandbox = self.active_sandboxes[sandbox_id]
            metadata = self.sandbox_metadata.get(sandbox_id, {})
            
            # Get sandbox info
            sandbox_info = await sandbox.get_info()
            
            status = {
                "sandbox_id": sandbox_id,
                "status": "active",
                "template": metadata.get("template"),
                "created_at": metadata.get("created_at"),
                "uptime": asyncio.get_event_loop().time() - metadata.get("created_at", 0),
                "memory_usage": sandbox_info.memory_usage if hasattr(sandbox_info, 'memory_usage') else None,
                "cpu_usage": sandbox_info.cpu_usage if hasattr(sandbox_info, 'cpu_usage') else None
            }
            
            return status
            
        except Exception as e:
            logger.error(f"Failed to get status for sandbox {sandbox_id}: {e}")
            raise
    
    async def get_all_sandbox_statuses(self) -> Dict[str, Dict[str, Any]]:
        """Get status of all active sandboxes."""
        try:
            statuses = {}
            for sandbox_id in self.active_sandboxes.keys():
                try:
                    statuses[sandbox_id] = await self.get_sandbox_status(sandbox_id)
                except Exception as e:
                    logger.warning(f"Failed to get status for sandbox {sandbox_id}: {e}")
                    statuses[sandbox_id] = {"status": "error", "error": str(e)}
            
            return statuses
            
        except Exception as e:
            logger.error(f"Failed to get all sandbox statuses: {e}")
            raise
    
    async def install_package(
        self,
        sandbox_id: str,
        package_name: str,
        version: Optional[str] = None
    ) -> bool:
        """
        Install a Python package in an E2B sandbox.
        
        Args:
            sandbox_id: ID of the sandbox
            package_name: Name of the package to install
            version: Package version (optional)
            
        Returns:
            True if installation was successful
        """
        try:
            if sandbox_id not in self.active_sandboxes:
                raise ValueError(f"Sandbox {sandbox_id} not found")
            
            sandbox = self.active_sandboxes[sandbox_id]
            
            # Build package specification
            if version:
                package_spec = f"{package_name}=={version}"
            else:
                package_spec = package_name
            
            logger.info(f"Installing package {package_spec} in sandbox {sandbox_id}")
            
            # Install package using python -m pip to avoid shell specifics
            install_code = (
                "import sys, subprocess;\n"
                f"subprocess.run([sys.executable, '-m', 'pip', 'install', '{package_spec}'], check=False)\n"
            )
            result = await sandbox.run_python(
                install_code,
                timeout=300
            )
            
            if result.exit_code == 0:
                logger.info(f"Package {package_spec} installed successfully in sandbox {sandbox_id}")
                return True
            else:
                logger.error(f"Package installation failed: {result.stderr}")
                return False
                
        except Exception as e:
            logger.error(f"Package installation failed in sandbox {sandbox_id}: {e}")
            raise
